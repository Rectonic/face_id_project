<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Песочница Face ID</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body data-known-count="{{ known_faces|length }}">
    <div class="wrapper">
        <h1>Песочница Face ID</h1>
        <p>
            Загрузите портреты, включите веб-камеру - и приложение поприветствует каждого, кого узнает. Галерея работает на базе
            детектора OpenCV и кастомной модели, разработанной Боисхоном на базе ArcFace.
        </p>

        <section class="panel" id="upload-panel">
            <h2>1. Добавьте ваши фото</h2>
            <form id="upload-form">
                <div class="form-group">
                    <label for="upload-name">Имя человека</label>
                    <input id="upload-name" type="text" placeholder="например, Иван Иванов" required>
                </div>
                <div id="upload-dropzone" class="dropzone" style="margin-top: 1rem;">
                    <p><strong>Перетащите портреты</strong> или нажмите, чтобы выбрать файлы</p>
                    <input id="upload-input" type="file" accept="image/*" multiple hidden>
                    <img id="upload-preview" alt="Предпросмотр" hidden>
                    <div id="upload-count" class="hint" hidden></div>
                </div>
                <div class="button-row">
                    <button type="submit">Загрузить фото</button>
                </div>
            </form>
            <div id="upload-error" class="error" hidden></div>
            <div id="upload-status" class="status"></div>
        </section>

        <section class="panel" id="match-panel">
            <h2>2. Живая проверка</h2>
            <p>
                Включите веб-камеру — и сверка будет идти автоматически, пока поток активен. При необходимости нажмите «Проверить сейчас». Чтобы сохранить фото с камеры в библиотеку Face ID, нажмите «Сделать снимок». 
            </p>
            <video id="live-video" class="video-feed" autoplay playsinline muted></video>
            <canvas id="capture-canvas" hidden></canvas>
            <div class="control-row">
                <button type="button" id="start-camera">Включить камеру</button>
                <button type="button" id="stop-camera" disabled>Выключить камеру</button>
                <button type="button" id="capture-photo" disabled>Сделать снимок</button>
                <button type="button" id="check-match" disabled>Проверить сейчас</button>
            </div>
            <div id="match-error" class="error" hidden></div>
            <div id="match-status" class="status"></div>
            <img id="match-result" class="result-image" alt="Результат сверки" hidden>
        </section>

        <div id="capture-modal" class="modal" hidden>
            <div class="modal-content">
                <h3>Сохранить снимок</h3>
                <p class="hint">
                    1. Нажмите «Сделать снимок», когда лицо хорошо видно в кадре.<br>
                    2. При необходимости скорректируйте имя — оно сохранится вместе с фото.<br>
                    3. Нажмите «Сохранить», чтобы добавить изображение в галерею.
                </p>
                <img id="capture-preview" alt="Захваченное изображение">
                <div class="form-group">
                    <label for="capture-name">Имя человека</label>
                    <input id="capture-name" type="text" placeholder="например, Иван Иванов">
                </div>
                <div id="capture-error" class="error" hidden></div>
                <div class="button-row">
                    <button type="button" id="cancel-capture">Отмена</button>
                    <button type="button" id="save-capture">Сохранить</button>
                </div>
            </div>
        </div>

    </div>

    <div id="global-loader" class="loader-overlay" hidden>
        <div class="spinner"></div>
        <div class="loader-text" id="loader-text">Модель обрабатывает ваше фото. Это может занять время</div>
    </div>

    <script>
        (function () {
            const MATCH_INTERVAL_MS = 2000;
            const state = {
                hasKnownFaces: {{ (known_faces|length > 0)|tojson }},
                mediaStream: null,
                statusTimeouts: new Map(),
                autoMatchTimer: null,
                autoMatchEnabled: false,
                matchInFlight: false,
                dynamicInterval: MATCH_INTERVAL_MS,
                pendingCaptureBlob: null,
                capturePreviewUrl: null,
                lastPersonName: "",
            };

            const liveVideo = document.getElementById("live-video");
            const captureCanvas = document.getElementById("capture-canvas");
            const startCameraBtn = document.getElementById("start-camera");
            const stopCameraBtn = document.getElementById("stop-camera");
            const checkMatchBtn = document.getElementById("check-match");
            const matchError = document.getElementById("match-error");
            const matchStatus = document.getElementById("match-status");
            const matchResult = document.getElementById("match-result");
            const uploadForm = document.getElementById("upload-form");
            const uploadName = document.getElementById("upload-name");
            const uploadDropzone = document.getElementById("upload-dropzone");
            const uploadInput = document.getElementById("upload-input");
            const uploadPreview = document.getElementById("upload-preview");
            const uploadCount = document.getElementById("upload-count");
            const uploadError = document.getElementById("upload-error");
            const uploadStatus = document.getElementById("upload-status");
            const capturePhotoBtn = document.getElementById("capture-photo");
            const captureModal = document.getElementById("capture-modal");
            const capturePreview = document.getElementById("capture-preview");
            const captureNameInput = document.getElementById("capture-name");
            const saveCaptureBtn = document.getElementById("save-capture");
            const cancelCaptureBtn = document.getElementById("cancel-capture");
            const captureError = document.getElementById("capture-error");
            const globalLoader = document.getElementById("global-loader");
            const loaderTextNode = document.getElementById("loader-text");
            const loaderInfoText = "Модель обрабатывает ваше фото. Это может занять время";
            let loaderDepth = 0;

            function setError(element, message) {
                if (!element) return;
                element.textContent = message || "";
                element.hidden = !message;
            }

            function showLoader(message) {
                if (!globalLoader) return;
                loaderDepth += 1;
                if (loaderTextNode) {
                    loaderTextNode.textContent = message
                        ? `${message}\n${loaderInfoText}`
                        : loaderInfoText;
                }
                globalLoader.hidden = false;
            }

            function hideLoader() {
                if (!globalLoader) return;
                loaderDepth = Math.max(0, loaderDepth - 1);
                if (loaderDepth === 0) {
                    globalLoader.hidden = true;
                    if (loaderTextNode) {
                        loaderTextNode.textContent = loaderInfoText;
                    }
                }
            }

            function setStatus(element, message, variant) {
                if (!element) return;
                element.textContent = message || "";
                element.classList.remove("success", "fail");
                if (variant) {
                    element.classList.add(variant);
                }
                const timeout = state.statusTimeouts.get(element);
                if (timeout) {
                    clearTimeout(timeout);
                }
                if (message) {
                    const handle = window.setTimeout(() => {
                        element.textContent = "";
                        element.classList.remove("success", "fail");
                        state.statusTimeouts.delete(element);
                    }, 5000);
                    state.statusTimeouts.set(element, handle);
                }
            }

            function showPreview(file, previewElement) {
                if (!file || !previewElement) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    previewElement.src = event.target.result;
                    previewElement.hidden = false;
                };
                reader.readAsDataURL(file);
            }

            function setInputFilesFromList(input, fileList) {
                if (!input || !fileList) return;
                if (window.DataTransfer) {
                    const dataTransfer = new DataTransfer();
                    Array.from(fileList).forEach((file) => dataTransfer.items.add(file));
                    input.files = dataTransfer.files;
                } else {
                    input.files = fileList;
                }
            }

            function setupDropzone(dropzone, input, preview, onFilesSelected) {
                if (!dropzone || !input) return;

                dropzone.addEventListener("click", () => input.click());

                dropzone.addEventListener("dragover", (event) => {
                    event.preventDefault();
                    dropzone.classList.add("dragover");
                });

                dropzone.addEventListener("dragleave", () => {
                    dropzone.classList.remove("dragover");
                });

                dropzone.addEventListener("drop", (event) => {
                    event.preventDefault();
                    dropzone.classList.remove("dragover");
                    if (event.dataTransfer.files.length) {
                        setInputFilesFromList(input, event.dataTransfer.files);
                        if (preview && input.files.length) {
                            showPreview(input.files[0], preview);
                        }
                        if (onFilesSelected) {
                            onFilesSelected(input.files);
                        }
                    }
                });

                input.addEventListener("change", (event) => {
                    if (event.target.files.length) {
                        if (preview) {
                            showPreview(event.target.files[0], preview);
                        }
                        if (onFilesSelected) {
                            onFilesSelected(input.files);
                        }
                    }
                });
            }

            function updateUploadSummary(files) {
                if (!uploadCount) return;
                if (!files || files.length === 0) {
                    uploadCount.textContent = "";
                    uploadCount.hidden = true;
                    if (uploadPreview) {
                        uploadPreview.src = "";
                        uploadPreview.hidden = true;
                    }
                    return;
                }
                uploadCount.textContent = files.length === 1
                    ? "Готово 1 фото"
                    : `Готово ${files.length} фото`;
                uploadCount.hidden = false;
            }

            function resetUploadForm() {
                if (uploadForm) {
                    uploadForm.reset();
                }
                if (uploadInput) {
                    uploadInput.value = "";
                }
                updateUploadSummary(null);
            }

            async function submitPortraits(personName, files, options = {}) {
                const {
                    label = "фото",
                    errorElement = uploadError,
                    statusElement = uploadStatus,
                    loaderText = "Загрузка...",
                    successStatus,
                } = options;
                const fileArray = Array.isArray(files) ? files : Array.from(files || []);
                if (!fileArray.length) {
                    throw new Error("Не выбраны файлы для загрузки.");
                }

                if (errorElement !== uploadError) {
                    setError(uploadError, "");
                }
                setError(errorElement, "");
                if (statusElement) {
                    setStatus(statusElement, `Загрузка ${label}...`);
                }
                showLoader(loaderText);

                const formData = new FormData();
                formData.append("person", personName);
                fileArray.forEach((file, index) => {
                    const namedFile = file instanceof File
                        ? file
                        : new File([file], `photo-${index}.jpg`, { type: "image/jpeg" });
                    formData.append("images", namedFile, namedFile.name || `photo-${index}.jpg`);
                });

                try {
                    const response = await fetch("/api/upload-face", {
                        method: "POST",
                        body: formData,
                    });
                    const payload = await response.json();
                    if (!response.ok || payload.error) {
                        throw new Error(payload.error || "Не удалось загрузить файлы.");
                    }

                    const saved = Number(payload.saved ?? fileArray.length);
                    const rejected = Array.isArray(payload.rejected) ? payload.rejected.length : 0;
                    let message = successStatus
                        || (saved === 1 ? "Сохранено 1 фото." : `Сохранено ${saved} фото.`);
                    if (rejected > 0) {
                        message += ` ${rejected} файл(ов) пропущено.`;
                    }
                    if (statusElement) {
                        setStatus(statusElement, message, "success");
                    }
                    state.lastPersonName = personName;
                    state.hasKnownFaces = true;
                    state.dynamicInterval = MATCH_INTERVAL_MS;
                    updateMatchControls();

                    return payload;
                } catch (error) {
                    if (statusElement) {
                        setStatus(statusElement, "");
                    }
                    setError(errorElement, error.message || "Не удалось загрузить файлы.");
                    throw error;
                } finally {
                    hideLoader();
                }
            }

            function openCaptureModal(blob) {
                if (!captureModal) return;
                if (state.capturePreviewUrl) {
                    URL.revokeObjectURL(state.capturePreviewUrl);
                }
                state.pendingCaptureBlob = blob;
                state.capturePreviewUrl = URL.createObjectURL(blob);
                if (capturePreview) {
                    capturePreview.src = state.capturePreviewUrl;
                    capturePreview.hidden = false;
                }
                if (captureNameInput) {
                    captureNameInput.value = "";
                    captureNameInput.placeholder = "Введите ваше имя";
                    captureNameInput.focus();
                }
                setError(captureError, "");
                captureModal.hidden = false;
                document.body.classList.add("modal-open");
            }

            function closeCaptureModal() {
                if (!captureModal) return;
                captureModal.hidden = true;
                document.body.classList.remove("modal-open");
                setError(captureError, "");
                if (state.capturePreviewUrl) {
                    URL.revokeObjectURL(state.capturePreviewUrl);
                    state.capturePreviewUrl = null;
                }
                state.pendingCaptureBlob = null;
                if (capturePreview) {
                    capturePreview.src = "";
                    capturePreview.hidden = true;
                }
                if (captureNameInput) {
                    captureNameInput.value = "";
                }
            }

            setupDropzone(uploadDropzone, uploadInput, uploadPreview, updateUploadSummary);
            updateUploadSummary(uploadInput ? uploadInput.files : null);

            function clearAutoMatchTimer() {
                if (state.autoMatchTimer) {
                    window.clearTimeout(state.autoMatchTimer);
                    state.autoMatchTimer = null;
                }
            }

            function stopAutoMatch() {
                state.autoMatchEnabled = false;
                clearAutoMatchTimer();
                state.dynamicInterval = MATCH_INTERVAL_MS;
            }

            function scheduleAutoMatch(delay) {
                if (!state.autoMatchEnabled) {
                    return;
                }
                clearAutoMatchTimer();
                const nextDelay = typeof delay === "number" ? delay : state.dynamicInterval;
                state.autoMatchTimer = window.setTimeout(async () => {
                    state.autoMatchTimer = null;
                    if (!state.autoMatchEnabled || !state.mediaStream) {
                        return;
                    }
                    if (!state.hasKnownFaces) {
                        scheduleAutoMatch(MATCH_INTERVAL_MS);
                        return;
                    }
                    if (state.matchInFlight) {
                        scheduleAutoMatch(MATCH_INTERVAL_MS);
                        return;
                    }
                    try {
                        await handleMatch({ isAuto: true });
                    } finally {
                        if (state.autoMatchEnabled) {
                            scheduleAutoMatch();
                        }
                    }
                }, nextDelay);
            }

            function beginAutoMatch(immediate = false) {
                if (!state.mediaStream) {
                    return;
                }
                state.autoMatchEnabled = true;
                state.dynamicInterval = MATCH_INTERVAL_MS;
                const delay = immediate ? 0 : MATCH_INTERVAL_MS;
                scheduleAutoMatch(delay);
            }

            function updateMatchControls() {
                const hasStream = Boolean(state.mediaStream);
                if (startCameraBtn) {
                    startCameraBtn.disabled = hasStream;
                }
                if (stopCameraBtn) {
                    stopCameraBtn.disabled = !hasStream;
                }
                if (checkMatchBtn) {
                    checkMatchBtn.disabled = !hasStream || !state.hasKnownFaces;
                }
            }

            if (uploadForm) {
                uploadForm.addEventListener("submit", async (event) => {
                    event.preventDefault();
                    setError(uploadError, "");
                    setStatus(uploadStatus, "");

                    const name = uploadName ? uploadName.value.trim() : "";
                    if (!name) {
                        setError(uploadError, "Укажите имя человека для добавления в галерею.");
                        return;
                    }

                    if (!uploadInput || uploadInput.files.length === 0) {
                        setError(uploadError, "Выберите хотя бы один портрет для загрузки.");
                        return;
                    }

                    const filesArray = Array.from(uploadInput.files || []);
                    try {
                        await submitPortraits(
                            name,
                            filesArray,
                            {
                                label: "фото",
                                loaderText: "Загружаем портреты...",
                                statusElement: uploadStatus,
                                errorElement: uploadError,
                            }
                        );
                        resetUploadForm();
                    } catch (error) {
                        // Error already surfaced by submitPortraits
                    }
                });
            }

            async function startCamera() {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    setError(matchError, "Браузер не поддерживает работу с камерой.");
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    liveVideo.srcObject = stream;
                    state.mediaStream = stream;
                    setError(matchError, "");
                    setStatus(matchStatus, "Камера готова.", "success");
                    if (capturePhotoBtn) {
                        capturePhotoBtn.disabled = false;
                    }
                    beginAutoMatch(true);
                    updateMatchControls();
                } catch (error) {
                    setError(matchError, error.message || "Не удалось получить доступ к камере.");
                    setStatus(matchStatus, "");
                    stopAutoMatch();
                }
            }

            function stopCamera() {
                if (state.mediaStream) {
                    state.mediaStream.getTracks().forEach((track) => track.stop());
                }
                liveVideo.srcObject = null;
                state.mediaStream = null;
                state.matchInFlight = false;
                matchResult.hidden = true;
                setStatus(matchStatus, "");
                stopAutoMatch();
                updateMatchControls();
                if (capturePhotoBtn) {
                    capturePhotoBtn.disabled = true;
                }
                closeCaptureModal();
            }

            function captureFrame() {
                return new Promise((resolve, reject) => {
                    if (!state.mediaStream) {
                        reject(new Error("Сначала включите камеру."));
                        return;
                    }
                    const width = liveVideo.videoWidth;
                    const height = liveVideo.videoHeight;
                    if (!width || !height) {
                        reject(new Error("Камера ещё не готова. Попробуйте через секунду."));
                        return;
                    }
                    captureCanvas.width = width;
                    captureCanvas.height = height;
                    const context = captureCanvas.getContext("2d");
                    context.drawImage(liveVideo, 0, 0, width, height);
                    captureCanvas.toBlob(
                        (blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error("Не удалось сохранить кадр."));
                            }
                        },
                        "image/jpeg",
                        0.95
                    );
                });
            }

            async function handleMatch(options = {}) {
                const { isAuto = false } = options;

                if (!state.mediaStream) {
                    if (!isAuto) {
                        setError(matchError, "Включите камеру перед проверкой.");
                    }
                    return;
                }

            if (!state.hasKnownFaces) {
                if (!isAuto) {
                    setError(matchError, "Сначала добавьте ваши фото в галерею.");
                }
                return;
            }

                if (state.matchInFlight) {
                    return;
                }

                state.matchInFlight = true;
                if (!isAuto) {
                    setError(matchError, "");
                    setStatus(matchStatus, "Сверяем лица...");
                }

                try {
                    const blob = await captureFrame();
                    const formData = new FormData();
                    formData.append("image", blob, "frame.jpg");
                    formData.append("matchThreshold", {{ default_match_threshold }});

                    const response = await fetch("/api/match", {
                        method: "POST",
                        body: formData,
                    });
                    const payload = await response.json();

                    if (!response.ok || payload.error) {
                        const err = new Error(payload.error || "Сверка лиц завершилась с ошибкой.");
                        err.status = response.status;
                        throw err;
                    }

                    state.hasKnownFaces = true;
                    state.dynamicInterval = MATCH_INTERVAL_MS;

                    const matched = Boolean(payload.match);
                    const similarity = Number(payload.similarity || 0);
                    const threshold = Number(
                        typeof payload.threshold === "number"
                            ? payload.threshold
                            : {{ default_match_threshold|tojson }}
                    );

                    if (payload.image) {
                        matchResult.src = payload.image;
                        matchResult.hidden = false;
                    }

                    let message = payload.greeting || (matched ? "Совпадение!" : "Лицо не распознано.");
                    message += ` Похожесть ${(similarity * 100).toFixed(1)}% (порог ${(threshold * 100).toFixed(1)}%).`;
                    const sampleCount = Number(payload.sample_count || 0);
                    if (sampleCount > 1 && matched) {
                        message += ` Используем ${sampleCount} эталонных фото.`;
                    } else if (!matched && sampleCount > 1 && payload.closest && payload.closest.name) {
                        message += ` Для ${payload.closest.name} доступно ${sampleCount} эталонных фото.`;
                    }
                    if (!matched && payload.closest && payload.closest.name) {
                        message += ` Ближайшее совпадение: ${payload.closest.name}.`;
                    }

                    setStatus(matchStatus, message, matched ? "success" : "fail");
                    setError(matchError, "");

                } catch (error) {
                    const message = error.message || "Сверка лиц завершилась с ошибкой.";
                    const status = typeof error.status === "number" ? error.status : null;

                    if (status === 429 || status === 503) {
                        state.dynamicInterval = Math.min(
                            state.dynamicInterval * 1.5,
                            MATCH_INTERVAL_MS * 5
                        );
                    }

                    const faceNotFound = /no face detected/i.test(message) || /не обнаружено лица/i.test(message);
                    if (isAuto && (status === 422 || faceNotFound)) {
                        setError(matchError, "");
                        setStatus(matchStatus, "Ищем лицо...");
                    } else {
                        setStatus(matchStatus, "");
                        setError(matchError, message);
                    }

                    if (/no known faces/i.test(message) || /нет эталонных лиц/i.test(message)) {
                        state.hasKnownFaces = false;
                        stopAutoMatch();
                    }
                } finally {
                    state.matchInFlight = false;
                    updateMatchControls();
                    if (state.autoMatchEnabled && !isAuto) {
                        scheduleAutoMatch();
                    }
                }
            }

            if (startCameraBtn) {
                startCameraBtn.addEventListener("click", async () => {
                    await startCamera();
                });
            }

            if (stopCameraBtn) {
                stopCameraBtn.addEventListener("click", () => {
                    stopCamera();
                });
            }

            if (checkMatchBtn) {
                checkMatchBtn.addEventListener("click", async () => {
                    await handleMatch();
                });
            }

            if (capturePhotoBtn) {
                capturePhotoBtn.addEventListener("click", async () => {
                    try {
                        const blob = await captureFrame();
                        openCaptureModal(blob);
                    } catch (error) {
                    setStatus(uploadStatus, "");
                    setError(uploadError, error.message || "Не удалось сохранить снимок.");
                    }
                });
            }

            if (saveCaptureBtn) {
                saveCaptureBtn.addEventListener("click", async () => {
                    if (!state.pendingCaptureBlob) {
                        setError(captureError, "Сначала сделайте снимок.");
                        return;
                    }
                    const name = captureNameInput ? captureNameInput.value.trim() : "";
                    if (!name) {
                        setError(captureError, "Введите имя, чтобы сохранить снимок.");
                        if (captureNameInput) {
                            captureNameInput.focus();
                        }
                        return;
                    }
                    const file = new File(
                        [state.pendingCaptureBlob],
                        `snapshot-${Date.now()}.jpg`,
                        { type: state.pendingCaptureBlob.type || "image/jpeg" }
                    );
                    try {
                        await submitPortraits(name, [file], {
                            label: "снимок",
                            errorElement: captureError,
                            statusElement: uploadStatus,
                            loaderText: "Сохраняем снимок...",
                            successStatus: "Снимок сохранён.",
                        });
                        closeCaptureModal();
                    } catch (error) {
                        // Error surfaced via captureError
                    }
                });
            }

            if (cancelCaptureBtn) {
                cancelCaptureBtn.addEventListener("click", () => {
                    closeCaptureModal();
                });
            }

            if (captureModal) {
                captureModal.addEventListener("click", (event) => {
                    if (event.target === captureModal) {
                        closeCaptureModal();
                    }
                });
            }

            document.addEventListener("keydown", (event) => {
                if (event.key === "Escape" && captureModal && !captureModal.hidden) {
                    closeCaptureModal();
                }
            });

            window.addEventListener("beforeunload", () => {
                stopCamera();
            });

            updateMatchControls();
        })();
    </script>
</body>
</html>
